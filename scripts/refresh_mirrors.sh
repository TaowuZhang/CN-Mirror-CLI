#!/usr/bin/env bash
set -euo pipefail

# 自动刷新国内镜像优先级（生成 mirrors.conf）
# - 仅调整 GH_PROXY_LIST 的顺序，不修改代码
# - 通过 curl 检测镜像可用性与延迟，生成排序结果
# - 清理临时文件，避免残留

log() { echo "[$(date '+%H:%M:%S')] $*"; }
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")"/.. && pwd)"
cd "$ROOT_DIR"

TMPDIR="$(mktemp -d)"
cleanup() { rm -rf "$TMPDIR"; }
trap cleanup EXIT

# 候选镜像（可按需扩展）
CANDIDATES=(
  "https://mirror.ghproxy.com/"
  "https://gh.api.99988866.xyz/"
)

# 测试 URL（小资源，返回稳定），通过镜像前缀代理到 GitHub 进行测试
TEST_TARGET="https://github.com/login"

rank_file="$TMPDIR/rank.tsv"
: > "$rank_file"

for p in "${CANDIDATES[@]}"; do
  test_url="${p}${TEST_TARGET}"
  # 返回 http_code 与耗时
  res=$(curl -s -o /dev/null -w '%{http_code}\t%{time_total}' --connect-timeout 8 -L "$test_url" || true)
  code=${res%%\t*}
  latency=${res##*\t}
  # 可用性评分：2xx/3xx 为 0（最佳）、否则 1
  usable=1
  if [[ "$code" =~ ^2|3 ]]; then usable=0; fi
  printf "%s\t%s\t%s\t%s\n" "$usable" "$latency" "$code" "$p" >> "$rank_file"
  log "probe: $p code=$code latency=${latency}s usable=$usable"
done

# 排序：先可用，再按延迟升序
mapfile -t sorted < <(sort -t $'\t' -k1,1n -k2,2n "$rank_file" | awk -F '\t' '{print $4}')

# 生成 mirrors.conf（仅覆盖 GH_PROXY_LIST 区域）
conf_path="$ROOT_DIR/mirrors.conf"
{
  echo "# Auto-generated by scripts/refresh_mirrors.sh on $(date)"
  echo "# Do not edit manually; edit scripts/refresh_mirrors.sh instead."
  echo ""
  echo "GH_PROXY_LIST=("
  for p in "${sorted[@]}"; do
    echo "  \"$p\""
  done
  echo ")"
} > "$conf_path"

log "written: $conf_path"

# 若运行于 CI，则自动提交
if [[ -n "${CI:-}" ]]; then
  git config user.name "github-actions[bot]"
  git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
  git add "$conf_path"
  if ! git diff --cached --quiet; then
    git commit -m "chore(mirrors): refresh GH_PROXY_LIST"
  else
    log "no changes to commit"
  fi
fi
